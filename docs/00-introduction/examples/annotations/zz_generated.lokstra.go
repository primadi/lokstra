// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by lokstra-annotation from annotations in this folder
// Annotations: @RouterService, @Service, @Inject, @InjectCfg, @Route

package application

import (
	"github.com/primadi/lokstra/core/deploy"
	"github.com/primadi/lokstra/core/proxy"
	"github.com/primadi/lokstra/lokstra_registry"
	time "time"
)

// Auto-register on package import
func init() {
	RegisterAdminAPIService()
	RegisterAuthService()
	RegisterBackgroundJobService()
	RegisterCacheManager()
	RegisterEmailService()
	RegisterNotificationService()
	RegisterProductAPIService()
	RegisterUserAPIService()
}

// ============================================================
// FILE: mixed_services_example.go
// ============================================================

// AdminAPIServiceRemote implements AdminAPIServiceInterface with HTTP proxy
// Auto-generated from AdminAPIService interface methods
type AdminAPIServiceRemote struct {
	proxyService *proxy.Service
}

// NewAdminAPIServiceRemote creates a new remote admin-api-service proxy
func NewAdminAPIServiceRemote(proxyService *proxy.Service) *AdminAPIServiceRemote {
	return &AdminAPIServiceRemote{
		proxyService: proxyService,
	}
}

// ListJobs via HTTP
// Generated from: @Route "GET /jobs"
func (s *AdminAPIServiceRemote) ListJobs(p *ListJobsRequest) (*JobListResponse, error) {
	return proxy.CallWithData[*JobListResponse](s.proxyService, "ListJobs", p)
}

// RestartJob via HTTP
// Generated from: @Route "POST /jobs/{id}/restart"
func (s *AdminAPIServiceRemote) RestartJob(p *RestartJobRequest) (*JobResponse, error) {
	return proxy.CallWithData[*JobResponse](s.proxyService, "RestartJob", p)
}


func AdminAPIServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &AdminAPIService{
		JobService: deps["background-job-service"].(*BackgroundJobService),
		EmailService: deps["email-service"].(*EmailService),
		AllowJobRestart: config["admin.allow-job-restart"].(bool),
		MaxJobsPerPage: config["admin.max-jobs-per-page"].(int),
	}
	
	return svc
}

// AdminAPIServiceRemoteFactory creates a remote HTTP client for AdminAPIServiceInterface
// Auto-generated from @RouterService annotation
func AdminAPIServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewAdminAPIServiceRemote(proxyService)
}

// RegisterAdminAPIService registers the admin-api-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="admin-api-service", prefix="/api/admin"
//   - @Inject annotations
//   - @InjectCfg annotations
//   - @Route annotations on methods
func RegisterAdminAPIService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("admin-api-service-factory",
		AdminAPIServiceFactory,
		AdminAPIServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/admin",
			Middlewares: []string{ "recovery", "auth", "admin" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"ListJobs": {
					Path: "GET /jobs",
				},
				"RestartJob": {
					Path: "POST /jobs/{id}/restart",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("admin-api-service",
		"admin-api-service-factory",
		map[string]any{
			"depends-on": []string{ "background-job-service", "email-service", },
			"admin.allow-job-restart": lokstra_registry.GetConfig("admin.allow-job-restart", true),
			"admin.max-jobs-per-page": lokstra_registry.GetConfig("admin.max-jobs-per-page", 50),
		})
}


// ============================================================
// FILE: service_example.go
// ============================================================

// RegisterAuthService registers the auth-service with the registry
// Auto-generated from annotations:
//   - @Service name="auth-service"
//   - @Inject annotations
//   - @InjectCfg annotations
func RegisterAuthService() {
	lokstra_registry.RegisterLazyService("auth-service", func(deps map[string]any, cfg map[string]any) any {
		svc := &AuthService{
			Cache: deps["cache-service"].(CacheService),
			UserRepo: deps["user-repository"].(UserRepository),
			DebugMode: cfg["auth.debug-mode"].(bool),
			JwtSecret: cfg["auth.jwt-secret"].(string),
			MaxAttempts: cfg["auth.max-attempts"].(int),
			TokenExpiry: cfg["auth.token-expiry"].(time.Duration),
		}
		
		return svc
	}, map[string]any{
		"depends-on": []string{ "cache-service", "user-repository", },
		"auth.debug-mode": lokstra_registry.GetConfig("auth.debug-mode", false),
		"auth.jwt-secret": lokstra_registry.GetConfig("auth.jwt-secret", ""),
		"auth.max-attempts": lokstra_registry.GetConfig("auth.max-attempts", 5),
		"auth.token-expiry": lokstra_registry.GetConfig("auth.token-expiry", 24*time.Hour),
	})
}


// ============================================================
// FILE: mixed_services_example.go
// ============================================================

// RegisterBackgroundJobService registers the background-job-service with the registry
// Auto-generated from annotations:
//   - @Service name="background-job-service"
//   - @Inject annotations
//   - @InjectCfg annotations
func RegisterBackgroundJobService() {
	lokstra_registry.RegisterLazyService("background-job-service", func(deps map[string]any, cfg map[string]any) any {
		svc := &BackgroundJobService{
			EmailService: deps["email-service"].(*EmailService),
			MaxWorkers: cfg["jobs.max-workers"].(int),
			RetryDelay: cfg["jobs.retry-delay"].(time.Duration),
			RetryLimit: cfg["jobs.retry-limit"].(int),
		}
		
		return svc
	}, map[string]any{
		"depends-on": []string{ "email-service", },
		"jobs.max-workers": lokstra_registry.GetConfig("jobs.max-workers", 10),
		"jobs.retry-delay": lokstra_registry.GetConfig("jobs.retry-delay", 5*time.Second),
		"jobs.retry-limit": lokstra_registry.GetConfig("jobs.retry-limit", 3),
	})
}


// ============================================================
// FILE: init_example.go
// ============================================================

// RegisterCacheManager registers the cache-manager with the registry
// Auto-generated from annotations:
//   - @Service name="cache-manager"
//   - @InjectCfg annotations
func RegisterCacheManager() {
	lokstra_registry.RegisterLazyService("cache-manager", func(deps map[string]any, cfg map[string]any) any {
		svc := &CacheManager{
			MaxSize: cfg["cache.max-size"].(int),
			TTLSeconds: cfg["cache.ttl-seconds"].(int),
		}
		
		// Call Init() for post-initialization
		if err := svc.Init(); err != nil {
			panic("failed to initialize cache-manager: " + err.Error())
		}
		
		return svc
	}, map[string]any{
		"cache.max-size": lokstra_registry.GetConfig("cache.max-size", 1000),
		"cache.ttl-seconds": lokstra_registry.GetConfig("cache.ttl-seconds", 300),
	})
}


// ============================================================
// FILE: mixed_services_example.go
// ============================================================

// RegisterEmailService registers the email-service with the registry
// Auto-generated from annotations:
//   - @Service name="email-service"
//   - @InjectCfg annotations
func RegisterEmailService() {
	lokstra_registry.RegisterLazyService("email-service", func(deps map[string]any, cfg map[string]any) any {
		svc := &EmailService{
			FromEmail: cfg["email.from"].(string),
			SMTPHost: cfg["smtp.host"].(string),
			SMTPPassword: cfg["smtp.password"].(string),
			SMTPPort: cfg["smtp.port"].(int),
			SMTPUsername: cfg["smtp.username"].(string),
		}
		
		return svc
	}, map[string]any{
		"email.from": lokstra_registry.GetConfig("email.from", "noreply@example.com"),
		"smtp.host": lokstra_registry.GetConfig("smtp.host", ""),
		"smtp.password": lokstra_registry.GetConfig("smtp.password", ""),
		"smtp.port": lokstra_registry.GetConfig("smtp.port", 587),
		"smtp.username": lokstra_registry.GetConfig("smtp.username", ""),
	})
}


// ============================================================
// FILE: service_example.go
// ============================================================

// RegisterNotificationService registers the notification-service with the registry
// Auto-generated from annotations:
//   - @Service name="notification-service"
//   - @InjectCfg annotations
func RegisterNotificationService() {
	lokstra_registry.RegisterLazyService("notification-service", func(deps map[string]any, cfg map[string]any) any {
		svc := &NotificationService{
			Enabled: cfg["notification.enabled"].(bool),
			FromEmail: cfg["smtp.from-email"].(string),
			SMTPHost: cfg["smtp.host"].(string),
			SMTPPort: cfg["smtp.port"].(int),
		}
		
		return svc
	}, map[string]any{
		"notification.enabled": lokstra_registry.GetConfig("notification.enabled", true),
		"smtp.from-email": lokstra_registry.GetConfig("smtp.from-email", "noreply@example.com"),
		"smtp.host": lokstra_registry.GetConfig("smtp.host", ""),
		"smtp.port": lokstra_registry.GetConfig("smtp.port", 587),
	})
}


// ============================================================
// FILE: router_with_init_example.go
// ============================================================

// ProductAPIServiceRemote implements ProductAPIServiceInterface with HTTP proxy
// Auto-generated from ProductAPIService interface methods
type ProductAPIServiceRemote struct {
	proxyService *proxy.Service
}

// NewProductAPIServiceRemote creates a new remote product-api proxy
func NewProductAPIServiceRemote(proxyService *proxy.Service) *ProductAPIServiceRemote {
	return &ProductAPIServiceRemote{
		proxyService: proxyService,
	}
}

// GetProduct via HTTP
// Generated from: @Route "GET /{id}"
func (s *ProductAPIServiceRemote) GetProduct(p *GetProductRequest) (*ProductResponse, error) {
	return proxy.CallWithData[*ProductResponse](s.proxyService, "GetProduct", p)
}

// ListProducts via HTTP
// Generated from: @Route "GET /"
func (s *ProductAPIServiceRemote) ListProducts(p *ListProductsRequest) (*ProductListResponse, error) {
	return proxy.CallWithData[*ProductListResponse](s.proxyService, "ListProducts", p)
}


func ProductAPIServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &ProductAPIService{
		ProductRepo: deps["product-repository"].(ProductRepository),
		MaxItems: config["api.products.max-items"].(int),
	}
	
	// Call Init() for post-initialization
	if err := svc.Init(); err != nil {
		panic("failed to initialize product-api: " + err.Error())
	}
	
	return svc
}

// ProductAPIServiceRemoteFactory creates a remote HTTP client for ProductAPIServiceInterface
// Auto-generated from @RouterService annotation
func ProductAPIServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewProductAPIServiceRemote(proxyService)
}

// RegisterProductAPIService registers the product-api with the registry
// Auto-generated from annotations:
//   - @RouterService name="product-api", prefix="/api/products"
//   - @Inject annotations
//   - @InjectCfg annotations
//   - @Route annotations on methods
func RegisterProductAPIService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("product-api-factory",
		ProductAPIServiceFactory,
		ProductAPIServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/products",
			Middlewares: []string{  },
			RouteOverrides: map[string]deploy.RouteConfig{
				"GetProduct": {
					Path: "GET /{id}",
				},
				"ListProducts": {
					Path: "GET /",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("product-api",
		"product-api-factory",
		map[string]any{
			"depends-on": []string{ "product-repository", },
			"api.products.max-items": lokstra_registry.GetConfig("api.products.max-items", 100),
		})
}


// ============================================================
// FILE: router_service_with_config_example.go
// ============================================================

// UserAPIServiceRemote implements UserAPIServiceInterface with HTTP proxy
// Auto-generated from UserAPIService interface methods
type UserAPIServiceRemote struct {
	proxyService *proxy.Service
}

// NewUserAPIServiceRemote creates a new remote user-api-service proxy
func NewUserAPIServiceRemote(proxyService *proxy.Service) *UserAPIServiceRemote {
	return &UserAPIServiceRemote{
		proxyService: proxyService,
	}
}

// Create via HTTP
// Generated from: @Route "POST /"
func (s *UserAPIServiceRemote) Create(p *CreateUserRequest) (*UserResponse, error) {
	return proxy.CallWithData[*UserResponse](s.proxyService, "Create", p)
}

// Delete via HTTP
// Generated from: @Route "DELETE /{id}"
func (s *UserAPIServiceRemote) Delete(p *DeleteUserRequest) error {
	return proxy.Call(s.proxyService, "Delete", p)
}

// GetByID via HTTP
// Generated from: @Route "GET /{id}"
func (s *UserAPIServiceRemote) GetByID(p *GetUserRequest) (*UserResponse, error) {
	return proxy.CallWithData[*UserResponse](s.proxyService, "GetByID", p)
}

// List via HTTP
// Generated from: @Route "GET /"
func (s *UserAPIServiceRemote) List(p *ListUsersRequest) (*UserListResponse, error) {
	return proxy.CallWithData[*UserListResponse](s.proxyService, "List", p)
}

// Update via HTTP
// Generated from: @Route "PUT /{id}"
func (s *UserAPIServiceRemote) Update(p *UpdateUserRequest) (*UserResponse, error) {
	return proxy.CallWithData[*UserResponse](s.proxyService, "Update", p)
}


func UserAPIServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &UserAPIService{
		Cache: deps["cache-service"].(CacheService),
		UserRepo: deps["user-repository"].(UserRepository),
		JwtSecret: config["api.jwt-secret"].(string),
		DefaultPageSize: config["api.pagination.default-page-size"].(int),
		MaxPageSize: config["api.pagination.max-page-size"].(int),
		RateLimitEnabled: config["api.rate-limit.enabled"].(bool),
		MaxRequests: config["api.rate-limit.max-requests"].(int),
		RateLimitWindow: config["api.rate-limit.window"].(time.Duration),
		IncludeMetadata: config["api.response.include-metadata"].(bool),
		TokenExpiry: config["api.token-expiry"].(time.Duration),
	}
	
	return svc
}

// UserAPIServiceRemoteFactory creates a remote HTTP client for UserAPIServiceInterface
// Auto-generated from @RouterService annotation
func UserAPIServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewUserAPIServiceRemote(proxyService)
}

// RegisterUserAPIService registers the user-api-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="user-api-service", prefix="/api/v1/users"
//   - @Inject annotations
//   - @InjectCfg annotations
//   - @Route annotations on methods
func RegisterUserAPIService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("user-api-service-factory",
		UserAPIServiceFactory,
		UserAPIServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/v1/users",
			Middlewares: []string{ "recovery", "request-logger" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"Create": {
					Path: "POST /",
					Middlewares: []string{ "auth" },
				},
				"Delete": {
					Path: "DELETE /{id}",
					Middlewares: []string{ "auth", "admin" },
				},
				"GetByID": {
					Path: "GET /{id}",
				},
				"List": {
					Path: "GET /",
				},
				"Update": {
					Path: "PUT /{id}",
					Middlewares: []string{ "auth" },
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("user-api-service",
		"user-api-service-factory",
		map[string]any{
			"depends-on": []string{ "cache-service", "user-repository", },
			"api.jwt-secret": lokstra_registry.GetConfig("api.jwt-secret", ""),
			"api.pagination.default-page-size": lokstra_registry.GetConfig("api.pagination.default-page-size", 20),
			"api.pagination.max-page-size": lokstra_registry.GetConfig("api.pagination.max-page-size", 100),
			"api.rate-limit.enabled": lokstra_registry.GetConfig("api.rate-limit.enabled", true),
			"api.rate-limit.max-requests": lokstra_registry.GetConfig("api.rate-limit.max-requests", 100),
			"api.rate-limit.window": lokstra_registry.GetConfig("api.rate-limit.window", 1*time.Minute),
			"api.response.include-metadata": lokstra_registry.GetConfig("api.response.include-metadata", true),
			"api.token-expiry": lokstra_registry.GetConfig("api.token-expiry", 24*time.Hour),
		})
}


