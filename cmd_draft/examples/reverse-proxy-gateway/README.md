# Reverse Proxy Gateway Example

This example demonstrates how to use Lokstra as an **API Gateway** with reverse proxy configuration.

## Features

✅ **Pure Reverse Proxy Mode** - No routers needed, just configure proxies in YAML  
✅ **Strip Prefix Support** - Optionally strip the prefix before forwarding  
✅ **Hybrid Mode** - Combine reverse proxies with regular routers  
✅ **Multiple Backends** - Route different prefixes to different backend services

## Configuration

### Pure Reverse Proxy Gateway

```yaml
servers:
  - name: api-gateway
    base-url: http://localhost
    apps:
      - name: gateway
        addr: ":8080"
        reverse-proxies:
          - prefix: /api
            strip-prefix: true
            target: http://api-server:8080
```

This configuration:
- Listens on `:8080`
- Routes `/api/*` requests to `http://api-server:8080/*`
- Strips the `/api` prefix before forwarding

**Example requests:**
```
http://localhost:8080/api/users       -> http://api-server:8080/users
http://localhost:8080/api/products    -> http://api-server:8080/products
```

### With Prefix Preservation

```yaml
reverse-proxies:
  - prefix: /auth
    strip-prefix: false  # Keep the prefix
    target: http://auth-service:9000
```

**Example requests:**
```
http://localhost:8080/auth/login      -> http://auth-service:9000/auth/login
http://localhost:8080/auth/logout     -> http://auth-service:9000/auth/logout
```

### Hybrid Mode (Proxy + Routers)

```yaml
apps:
  - name: hybrid
    addr: ":8090"
    reverse-proxies:
      - prefix: /external
        strip-prefix: true
        target: http://external-api:8080
    routers:
      - internal-router
```

This combines:
1. **Reverse proxies** (mounted first) - for external services
2. **Regular routers** (mounted after) - for internal handlers

## How It Works

Under the hood, Lokstra automatically creates a router for reverse proxies:

```go
// Automatically generated by config loader
r := lokstra.NewRouter("gateway-reverse-proxy")
r.ANYPrefix("/api", lokstra_handler.MountReverseProxy("/api", "http://api-server:8080"))
```

## Use Cases

### 1. Simple API Gateway
Route all traffic to a single backend service.

### 2. Microservices Gateway
Route different paths to different microservices.

```yaml
reverse-proxies:
  - prefix: /users
    target: http://user-service:8001
  - prefix: /orders
    target: http://order-service:8002
  - prefix: /payments
    target: http://payment-service:8003
```

### 3. API Versioning
Route different versions to different backends.

```yaml
reverse-proxies:
  - prefix: /v1
    target: http://api-v1:8080
  - prefix: /v2
    target: http://api-v2:8081
```

### 4. Development Proxy
Forward to local services during development.

```yaml
reverse-proxies:
  - prefix: /api
    strip-prefix: true
    target: http://localhost:3000
```

## Code Equivalent

If you prefer code over config, you can achieve the same result:

```go
package main

import (
	"github.com/primadi/lokstra"
	"github.com/primadi/lokstra/lokstra_handler"
)

func main() {
	r := lokstra.NewRouter("gateway")
	
	// Mount reverse proxy
	r.ANYPrefix("/api", lokstra_handler.MountReverseProxy("/api", "http://api-server:8080"))
	
	app := lokstra.NewApp("gateway", ":8080", r)
	app.Run(5 * time.Second)
}
```

## Comparison: Config vs Code

| Aspect | Config (YAML) | Code (Go) |
|--------|---------------|-----------|
| **Ease of use** | ✅ Very easy | ⚠️ Requires coding |
| **Dynamic updates** | ✅ Edit YAML | ❌ Rebuild binary |
| **Type safety** | ⚠️ Runtime validation | ✅ Compile-time |
| **Best for** | API Gateway, Ops | Complex logic, Dev |

## Running the Example

1. Create backend services (or use mock servers)
2. Update `config.yaml` with correct backend URLs
3. Run:
   ```bash
   go run main.go
   ```

## Notes

- Reverse proxies are **always mounted first** (before regular routers)
- `strip-prefix: true` removes the prefix before forwarding
- `strip-prefix: false` (or omitted) keeps the prefix
- Multiple proxies can be configured per app
- Hybrid mode allows mixing proxies with regular routers
