# Example 18: Service Router (Auto-Generated Routes)

This example demonstrates the automatic router generation feature that creates HTTP routes from service methods using naming conventions.

## Key Features

### 1. **Convention-Based Routing**
Instead of manually registering each route, the router automatically generates routes based on method names:

```go
type UserService struct {
    users map[string]*User
}

// Convention: GetUser -> GET /users/{id}
func (s *UserService) GetUser(ctx *request.Context, id string) (*User, error) {
    return s.users[id], nil
}

// Convention: ListUsers -> GET /users
func (s *UserService) ListUsers(ctx *request.Context) ([]*User, error) {
    // ...
}

// Convention: CreateUser -> POST /users
func (s *UserService) CreateUser(ctx *request.Context, req *CreateUserRequest) (*User, error) {
    // ...
}

// Convention: UpdateUser -> PUT /users/{id}
func (s *UserService) UpdateUser(ctx *request.Context, id string, req *UpdateUserRequest) (*User, error) {
    // ...
}

// Convention: DeleteUser -> DELETE /users/{id}
func (s *UserService) DeleteUser(ctx *request.Context, id string) error {
    // ...
}
```

### 2. **Auto-Generated Router**
Create a router from the service with one line:

```go
router := router.NewFromService(
    userService,
    router.DefaultServiceRouterOptions().
        WithPrefix("/api/v1"),
)
```

### 3. **Convention Rules**

| Method Pattern | HTTP Method | Path Pattern | Example |
|----------------|-------------|--------------|---------|
| `Get{Resource}` | GET | `/{resources}/{id}` | `GetUser` → `GET /users/{id}` |
| `List{Resources}` | GET | `/{resources}` | `ListUsers` → `GET /users` |
| `Create{Resource}` | POST | `/{resources}` | `CreateUser` → `POST /users` |
| `Update{Resource}` | PUT | `/{resources}/{id}` | `UpdateUser` → `PUT /users/{id}` |
| `Delete{Resource}` | DELETE | `/{resources}/{id}` | `DeleteUser` → `DELETE /users/{id}` |
| `Search{Resources}` | GET | `/{resources}/search` | `SearchUsers` → `GET /users/search` |
| `Find{Resources}` | GET | `/{resources}` | `FindUsers` → `GET /users` |
| `Modify{Resource}` | PATCH | `/{resources}/{id}` | `ModifyUser` → `PATCH /users/{id}` |

## Boilerplate Reduction

### Traditional Approach (Manual Router)
```go
// ~30 lines per endpoint
r.GET("/api/v1/users/{id}", func(ctx *request.Context) error {
    id := ctx.Req.PathParam("id", "")
    user, err := service.GetUser(ctx, id)
    if err != nil {
        ctx.Resp.WithStatus(400).Json(map[string]interface{}{
            "success": false,
            "error":   err.Error(),
        })
        return err
    }
    ctx.Resp.Json(map[string]interface{}{
        "success": true,
        "data":    user,
    })
    return nil
})

// Repeat for POST, PUT, DELETE... (150+ lines total)
```

### Convention-Based Approach (Service Router)
```go
// ~5 lines total for all endpoints
router := router.NewFromService(
    userService,
    router.DefaultServiceRouterOptions().
        WithPrefix("/api/v1"),
)
```

**Result:** ~95% less boilerplate code!

## How It Works

1. **Reflection Discovery**: The router scans all exported methods on your service using reflection

2. **Convention Parsing**: Method names are parsed to determine:
   - HTTP method (GET, POST, PUT, DELETE, PATCH)
   - URL path (with proper pluralization)
   - Path parameters (e.g., `{id}`)

3. **Automatic Binding**: 
   - First parameter: always `*request.Context`
   - Second parameter (optional): path parameter (e.g., `id`)
   - Third parameter (optional): request body (auto-bound from JSON)

4. **Response Handling**:
   - Return values are automatically converted to JSON responses
   - Errors are caught and formatted as error responses
   - Success responses include `{success: true, data: ...}`

## Running the Example

```bash
go run main.go
```

## Testing with curl

```bash
# List all users
curl http://localhost:8080/api/v1/users

# Get specific user
curl http://localhost:8080/api/v1/users/1

# Create new user
curl -X POST http://localhost:8080/api/v1/users \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice Brown","email":"alice@example.com"}'

# Update user
curl -X PUT http://localhost:8080/api/v1/users/1 \
  -H "Content-Type: application/json" \
  -d '{"name":"John Updated","email":"john.updated@example.com"}'

# Delete user
curl -X DELETE http://localhost:8080/api/v1/users/1

# Search users
curl "http://localhost:8080/api/v1/users/search?q=john"
```

## Advanced Configuration

### Custom Resource Names
```go
opts := router.DefaultServiceRouterOptions().
    WithPrefix("/api/v1").
    WithResourceName("person").          // Override auto-detected name
    WithPluralResourceName("people")     // Custom pluralization
```

### Route Overrides
```go
opts := router.DefaultServiceRouterOptions().
    WithPrefix("/api/v1").
    WithRouteOverride("SearchUsers", router.RouteMeta{
        HTTPMethod: "GET",
        Path: "/users/advanced-search",  // Custom path
    })
```

## Benefits

1. **Less Boilerplate**: Eliminate repetitive route registration code
2. **Type Safety**: Service methods define the API contract
3. **Consistency**: Convention ensures uniform API patterns
4. **Maintainability**: Changes to service methods automatically reflect in routes
5. **Testability**: Test service logic independently of routing
6. **Self-Documenting**: Method names clearly indicate HTTP operations

## Comparison with Manual Router

The example includes both approaches side-by-side. Run it to see:

1. **Code Size**: Convention-based is ~10x smaller
2. **Route Generation**: Both produce identical routes
3. **Behavior**: Both handle requests identically
4. **Maintenance**: Convention-based requires fewer updates

## Design Philosophy

The service router feature follows these principles:

- **Convention over Configuration**: Smart defaults that work 80% of the time
- **Escape Hatches**: Override any convention when needed
- **Progressive Enhancement**: Start simple, add complexity only when required
- **Zero Magic**: Clear, predictable behavior based on method signatures

## When to Use

✅ **Use Convention-Based Router When:**
- Building RESTful APIs with standard CRUD operations
- You want to reduce boilerplate
- Your team prefers convention over configuration
- Service methods follow REST patterns

❌ **Use Manual Router When:**
- Routes don't follow REST conventions
- You need complex route patterns
- You're migrating existing non-standard APIs
- You prefer explicit over implicit

## Next Steps

1. **Try Phase 2**: Annotation-based overrides (coming soon)
2. **Explore**: Combine with middleware for auth, logging, etc.
3. **Customize**: Use route overrides for special cases
4. **Test**: Write service tests independent of HTTP layer
