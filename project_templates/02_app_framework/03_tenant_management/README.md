# Lokstra Tenant Management Template

**Hero example for Track 2 ‚Äì Application Framework**

This template shows how to build a small, focused **Tenant Management service**
using Lokstra's **initialization helpers**, **YAML config**, and
**annotation-based code generation**:

- `lokstra_init.BootstrapAndRun()`
- `config/config.yaml` with `configs`, `dbpool-definitions`, and `servers`
- `@Handler`, `@Inject`, and `@Route` annotations

---

## üìå When to Use This Template

Use this template when you want to learn how to:

- Build a **single, focused service** (tenant management / multi-tenant building block).
- Expose REST APIs using **annotation-based handler**.
- Use `lokstra_init.BootstrapAndRun()` with the **default bootstrap flow**.

This is the **recommended hero example** for understanding Lokstra's
Application Framework mode (Track 2) with minimal noise.

---

## üèó Project Structure

```text
03_tenant_management/
‚îú‚îÄ‚îÄ handler/
‚îÇ   ‚îî‚îÄ‚îÄ tenant_handler.go          # @Handler + @Inject + @Route
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ config.yaml                # YAML config (configs, dbpool-definitions, servers)
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ tenant.go                  # Tenant entities & DTOs (requests)
‚îú‚îÄ‚îÄ repository/
‚îÇ   ‚îú‚îÄ‚îÄ contract.go                # TenantRepository interface
    ‚îî‚îÄ‚îÄ postgres
‚îÇ       ‚îî‚îÄ‚îÄ tenant_repository.go   # Postgres-backed implementation
‚îú‚îÄ‚îÄ main.go                        # Bootstrap with lokstra_init.BootstrapAndRun()
‚îú‚îÄ‚îÄ tenant-handler.http            # VS Code / Cursor HTTP test file
‚îú‚îÄ‚îÄ zz_cache.lokstra.json          # Autogen cache (generated)
‚îî‚îÄ‚îÄ zz_generated.lokstra.go        # Autogenerated code (DO NOT EDIT)
```

---

## üöÄ Quick Start

> Run from the **repository root** (where `go.mod` is).

```bash
go run ./project_templates/02_app_framework/03_tenant_management
```

Requirements:

- Go 1.23+
- PostgreSQL running and reachable with DSN in `config/config.yaml`:

```yaml
dbpool-definitions:
  db_auth:
    dsn: ${GLOBAL_DB_DSN:postgres://postgres:adm1n@localhost:5432/lokstra_db}
    schema: ${GLOBAL_DB_SCHEMA:lokstra_auth}
```

**Test the API:**

1. Open `tenant-service.http` in VS Code / Cursor.
2. Use the REST Client extension (VS Code) or built-in HTTP client (Cursor).
3. Click **"Send Request"** on each request block (create, get, list, update, delete).

Base URL in the `.http` file:

```http
@baseUrl = http://localhost:3000/api/auth/core/tenants
```

---

## ‚öôÔ∏è Bootstrap Flow (`lokstra_init.BootstrapAndRun`)

`main.go`:

```go
recovery.Register()
request_logger.Register()

lokstra_init.BootstrapAndRun()
```

Key points:

- **Built-in middleware** is registered **manually** before bootstrap:
  - `recovery.Register()`
  - `request_logger.Register()`
- `BootstrapAndRun()` then:
  - Loads configuration (by default from `config/` next to the binary).
  - Initializes internal registries and services (including db pools).
  - Starts the HTTP server(s) defined in the config.

For **more advanced setups** (when initialization needs access to `configs`),
you would use:

```go
lokstra_init.BootstrapAndRun(
    lokstra_init.WithServerInitFunc(func() error {
        // Custom initialization that needs loaded configs
        return nil
    }),
)
```

In this template, the **default flow is enough**, because initialization
does not depend on values from `configs`.

---

## üßæ YAML Config Overview (`config/config.yaml`)

```yaml
configs:
  repository:
    tenant-repository: postgres-tenant-repository

dbpool-definitions:
  db_auth:
    dsn: ${GLOBAL_DB_DSN:postgres://postgres:adm1n@localhost:5432/lokstra_db}
    schema: ${GLOBAL_DB_SCHEMA:lokstra_auth}

servers:
  api-server:
    base-url: "http://localhost"
    addr: ":3000"
    published-services: [tenant-service]
```

Key sections:

- **`configs.repository.tenant-repository`**  
  - Declares a repository named `tenant-repository` implemented by `postgres-tenant-repository`
    (binding between config and repository implementation).
- **`dbpool-manager.db_auth`**  
  - Declares a **lazy DbPool service** named `db_auth`.
  - Configures a Postgres connection pool used by the tenant repository.
  - Uses env var fallbacks via `${VAR:default}` syntax.
- **`servers.api-server`**  
  - Configures the HTTP server (`:3000`).
  - `published-services: [tenant-service]` tells Lokstra to **expose** the
    `tenant-service` (defined via annotations) as REST endpoints.

---

## üß© Annotations: `@Handler`, `@Inject`, `@Route`

`application/tenant_service.go`:

```go
// @Handler name="tenant-service",
//   prefix="${api-auth-prefix:/api/auth}/core/tenants",
//   middlewares=["recovery", "request_logger"]
type TenantService struct {
    // @Inject "@repository.tenant-repository"
    repository repository.TenantRepository
}
```

What this does:

- **`@Handler`**
  - Registers a service named `tenant-service` in the Lokstra registry.
  - Generates an HTTP router with base path:
    - `${api-auth-prefix:/api/auth}/core/tenants`
    - Default: `/api/auth/core/tenants`, overridable via config/env.
  - Attaches middlewares: `recovery`, `request_logger`.

- **`@Inject "@repository.tenant-repository"`**
  - Tells the generator to inject a dependency into `repository` using a **lazy service reference**.
  - The `@repository.<key>` syntax means: look up `configs.repository.<key>` from YAML.
  - In `config.yaml` we have:
    - `configs.repository.tenant-repository = "postgres-tenant-repository"`
  - So at generation time, `@repository.tenant-repository` is effectively resolved as:
    - `@Inject "postgres-tenant-repository"`
  - That concrete service (`postgres-tenant-repository`) is then wired to the
    `repository.TenantRepository` implementation.

- **`@Inject "db_auth"` in `PostgresTenantRepository`**
  - In `repository/tenant_repository.go`:
    ```go
    type PostgresTenantRepository struct {
        // @Inject "db_auth"
        dbPool serviceapi.DbPool
    }
    ```
  - The `dbpool-definitions` section in `config.yaml` creates a **lazy DbPool service**
    with the same name as the key:
    - `dbpool-manager.db_auth` ‚Üí lazy service `"db_auth"`.
  - Therefore `@Inject "db_auth"` is resolved by the framework and injects the
    configured `DbPool` instance into `dbPool`.

Each method annotated with `@Route` becomes an endpoint:

```go
// @Route "POST /"
func (s *TenantService) CreateTenant(ctx *request.Context,
    req *domain.CreateTenantRequest) (*domain.Tenant, error) { ... }

// @Route "GET /{id}"
func (s *TenantService) GetTenant(ctx *request.Context,
    req *domain.GetTenantRequest) (*domain.Tenant, error) { ... }

// @Route "PUT /{id}"
func (s *TenantService) UpdateTenant(...)

// @Route "DELETE /{id}"
func (s *TenantService) DeleteTenant(...)

// @Route "GET /"
func (s *TenantService) ListTenants(...)

// @Route "POST /{id}/activate"
func (s *TenantService) ActivateTenant(...)

// @Route "POST /{id}/suspend"
func (s *TenantService) SuspendTenant(...)
```

The **autogenerated** `zz_generated.lokstra.go` file:

- Parses `@Handler`, `@Inject`, and `@Route` annotations.
- Registers `tenant-service` in the registry.
- Generates the HTTP router that:
  - Binds path/query/body parameters to request DTOs.
  - Calls the corresponding Go method.
  - Serializes the result to JSON and handles errors.

> Do not edit `zz_generated.lokstra.go` manually.
> Re-run the generator when you change annotations.

---

## üîå Repository and DB Integration

The repository layer (see `repository/contract.go` and `tenant_repository.go`):

- Implements a `TenantRepository` interface with operations like:
  - `Create`, `Get`, `Update`, `Delete`, `Exists`, `List`.
- Uses the `db_auth` pool configured in `config.yaml`.

The wiring between:

- `configs.repository.tenant-repository`
- `dbpool-manager.db_auth`
- `repository.TenantRepository`
- `application.TenantService.repository`

is handled through **Lokstra registry + annotations + config**,
so your application code can stay focused on business logic.

---

## üß™ HTTP Testing (`tenant-service.http`)

The `tenant-service.http` file contains ready-to-use HTTP requests:

- `POST /api/auth/core/tenants` ‚Äì create a tenant.
- `GET /api/auth/core/tenants/{id}` ‚Äì get a tenant.
- `GET /api/auth/core/tenants` ‚Äì list tenants.
- `PUT /api/auth/core/tenants/{id}` ‚Äì update a tenant.
- `DELETE /api/auth/core/tenants/{id}` ‚Äì delete a tenant.

Use it to:

- Quickly experiment with the API.
- See how the service behaves with different payloads.
- Validate that your environment and database are wired correctly.

---

## üìö Next Steps

- Use this template as a **reference** when building your own tenant / account
  service or any small bounded context.
- Explore:
  - `docs2/02-framework-guide` (when available) for a higher-level explanation.
  - Other templates in `project_templates/02_app_framework/` for more
    advanced patterns (enterprise modular, sync config, etc.).

Happy coding with Lokstra! üöÄ


