// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by lokstra-annotation from annotations in this folder
// Annotations: @RouterService, @Inject, @Route

package main

import (
	"github.com/primadi/lokstra/core/deploy"
	"github.com/primadi/lokstra/core/proxy"
	"github.com/primadi/lokstra/lokstra_registry"
	authdomain "github.com/primadi/lokstra/core/annotation/internal/multifile_test/authdomain"
	userdomain "github.com/primadi/lokstra/core/annotation/internal/multifile_test/userdomain"
	service "github.com/primadi/lokstra/core/service"
)

// Auto-register on package import
func init() {
	RegisterAuthService()
	RegisterConfigEagerService()
	RegisterConfigService()
	RegisterProfileService()
	RegisterUserService()
}

// ============================================================
// FILE: auth_service.go
// ============================================================

// AuthServiceRemote implements AuthServiceInterface with HTTP proxy
// Auto-generated from AuthService interface methods
type AuthServiceRemote struct {
	proxyService *proxy.Service
}

// NewAuthServiceRemote creates a new remote auth-service proxy
func NewAuthServiceRemote(proxyService *proxy.Service) *AuthServiceRemote {
	return &AuthServiceRemote{
		proxyService: proxyService,
	}
}

// Login via HTTP
// Generated from: @Route "POST /login"
func (s *AuthServiceRemote) Login(p *authdomain.LoginRequest) (*authdomain.AuthResponse, error) {
	return proxy.CallWithData[*authdomain.AuthResponse](s.proxyService, "Login", p)
}

// Logout via HTTP
// Generated from: @Route "POST /logout"
func (s *AuthServiceRemote) Logout(p *authdomain.LogoutRequest) (*authdomain.AuthResponse, error) {
	return proxy.CallWithData[*authdomain.AuthResponse](s.proxyService, "Logout", p)
}


func AuthServiceFactory(deps map[string]any, config map[string]any) any {
	return &AuthService{
		AuthRepo: deps["auth-repo"].(*service.Cached[any]),
	}
}

// AuthServiceRemoteFactory creates a remote HTTP client for AuthServiceInterface
// Auto-generated from @RouterService annotation
func AuthServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewAuthServiceRemote(proxyService)
}

// RegisterAuthService registers the auth-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="auth-service", prefix="/api/v1/auth"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterAuthService() {
	// Register service type with router configuration
	lokstra_registry.RegisterServiceType("auth-service-factory",
		AuthServiceFactory,
		AuthServiceRemoteFactory,
		deploy.WithRouter(&deploy.ServiceTypeRouter{
			PathPrefix:  "/api/v1/auth",
			Middlewares: []string{  },
			CustomRoutes: map[string]string{
				"Login":  "POST /login",
				"Logout":  "POST /logout",
			},
		}),
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("auth-service",
		"auth-service-factory",
		map[string]any{
			"depends-on": []string{ "auth-repo",  },
		})
}

// ============================================================
// FILE: config_eager_service.go
// ============================================================

// ConfigEagerServiceRemote implements ConfigEagerServiceInterface with HTTP proxy
// Auto-generated from ConfigEagerService interface methods
type ConfigEagerServiceRemote struct {
	proxyService *proxy.Service
}

// NewConfigEagerServiceRemote creates a new remote config-eager-service proxy
func NewConfigEagerServiceRemote(proxyService *proxy.Service) *ConfigEagerServiceRemote {
	return &ConfigEagerServiceRemote{
		proxyService: proxyService,
	}
}

// GetStatus via HTTP
// Generated from: @Route "GET /status"
func (s *ConfigEagerServiceRemote) GetStatus() (any, error) {
	return proxy.CallWithData[any](s.proxyService, "GetStatus", nil)
}


func ConfigEagerServiceFactory(deps map[string]any, config map[string]any) any {
	return &ConfigEagerService{
		DB: deps["database"].(*DBPool),
		Redis: deps["redis"].(*RedisClient),
		UserRepo: deps["user-repository"].(*service.Cached[any]),
	}
}

// ConfigEagerServiceRemoteFactory creates a remote HTTP client for ConfigEagerServiceInterface
// Auto-generated from @RouterService annotation
func ConfigEagerServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewConfigEagerServiceRemote(proxyService)
}

// RegisterConfigEagerService registers the config-eager-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="config-eager-service", prefix="/api/v1/config"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterConfigEagerService() {
	// Register service type with router configuration
	lokstra_registry.RegisterServiceType("config-eager-service-factory",
		ConfigEagerServiceFactory,
		ConfigEagerServiceRemoteFactory,
		deploy.WithRouter(&deploy.ServiceTypeRouter{
			PathPrefix:  "/api/v1/config",
			Middlewares: []string{  },
			CustomRoutes: map[string]string{
				"GetStatus":  "GET /status",
			},
		}),
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("config-eager-service",
		"config-eager-service-factory",
		map[string]any{
			"depends-on": []string{ "database", "redis", "user-repository",  },
		})
}

// ============================================================
// FILE: config_service.go
// ============================================================

// ConfigServiceRemote implements ConfigServiceInterface with HTTP proxy
// Auto-generated from ConfigService interface methods
type ConfigServiceRemote struct {
	proxyService *proxy.Service
}

// NewConfigServiceRemote creates a new remote config-service proxy
func NewConfigServiceRemote(proxyService *proxy.Service) *ConfigServiceRemote {
	return &ConfigServiceRemote{
		proxyService: proxyService,
	}
}

// GetSettings via HTTP
// Generated from: @Route "GET /settings"
func (s *ConfigServiceRemote) GetSettings() (any, error) {
	return proxy.CallWithData[any](s.proxyService, "GetSettings", nil)
}

// GetVersion via HTTP
// Generated from: @Route "GET /version"
func (s *ConfigServiceRemote) GetVersion() (string, error) {
	return proxy.CallWithData[string](s.proxyService, "GetVersion", nil)
}

// Reload via HTTP
// Generated from: @Route "POST /reload"
func (s *ConfigServiceRemote) Reload() error {
	return proxy.Call(s.proxyService, "Reload", nil)
}

func ConfigServiceFactory(deps map[string]any, config map[string]any) any {
	return &ConfigService{
		ConfigRepo: deps["config-repo"].(*service.Cached[any]),
	}
}

// ConfigServiceRemoteFactory creates a remote HTTP client for ConfigServiceInterface
// Auto-generated from @RouterService annotation
func ConfigServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewConfigServiceRemote(proxyService)
}

// RegisterConfigService registers the config-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="config-service", prefix="/api/config"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterConfigService() {
	// Register service type with router configuration
	lokstra_registry.RegisterServiceType("config-service-factory",
		ConfigServiceFactory,
		ConfigServiceRemoteFactory,
		deploy.WithRouter(&deploy.ServiceTypeRouter{
			PathPrefix:  "/api/config",
			Middlewares: []string{  },
			CustomRoutes: map[string]string{
				"GetSettings":  "GET /settings",
				"GetVersion":  "GET /version",
				"Reload":  "POST /reload",
			},
		}),
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("config-service",
		"config-service-factory",
		map[string]any{
			"depends-on": []string{ "config-repo",  },
		})
}

// ============================================================
// FILE: profile_service.go
// ============================================================

// ProfileServiceRemote implements ProfileServiceInterface with HTTP proxy
// Auto-generated from ProfileService interface methods
type ProfileServiceRemote struct {
	proxyService *proxy.Service
}

// NewProfileServiceRemote creates a new remote profile-service proxy
func NewProfileServiceRemote(proxyService *proxy.Service) *ProfileServiceRemote {
	return &ProfileServiceRemote{
		proxyService: proxyService,
	}
}

// GetByID via HTTP
// Generated from: @Route "GET /profiles/{id}"
func (s *ProfileServiceRemote) GetByID(p string) (string, error) {
	return proxy.CallWithData[string](s.proxyService, "GetByID", p)
}

// Update via HTTP
// Generated from: @Route "PUT /profiles/{id}"
func (s *ProfileServiceRemote) Update(p string) error {
	return proxy.Call(s.proxyService, "Update", p)
}


func ProfileServiceFactory(deps map[string]any, config map[string]any) any {
	return &ProfileService{
		ProfileRepo: deps["profile-repo"].(*service.Cached[any]),
	}
}

// ProfileServiceRemoteFactory creates a remote HTTP client for ProfileServiceInterface
// Auto-generated from @RouterService annotation
func ProfileServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewProfileServiceRemote(proxyService)
}

// RegisterProfileService registers the profile-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="profile-service", prefix="/api/profiles"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterProfileService() {
	// Register service type with router configuration
	lokstra_registry.RegisterServiceType("profile-service-factory",
		ProfileServiceFactory,
		ProfileServiceRemoteFactory,
		deploy.WithRouter(&deploy.ServiceTypeRouter{
			PathPrefix:  "/api/profiles",
			Middlewares: []string{  },
			CustomRoutes: map[string]string{
				"GetByID":  "GET /profiles/{id}",
				"Update":  "PUT /profiles/{id}",
			},
		}),
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("profile-service",
		"profile-service-factory",
		map[string]any{
			"depends-on": []string{ "profile-repo",  },
		})
}


// ============================================================
// FILE: user_service.go
// ============================================================

// UserServiceRemote implements UserServiceInterface with HTTP proxy
// Auto-generated from UserService interface methods
type UserServiceRemote struct {
	proxyService *proxy.Service
}

// NewUserServiceRemote creates a new remote user-service proxy
func NewUserServiceRemote(proxyService *proxy.Service) *UserServiceRemote {
	return &UserServiceRemote{
		proxyService: proxyService,
	}
}

// Create via HTTP
// Generated from: @Route "POST /users"
func (s *UserServiceRemote) Create(p *userdomain.CreateUserRequest) (*userdomain.UserDTO, error) {
	return proxy.CallWithData[*userdomain.UserDTO](s.proxyService, "Create", p)
}

// GetByID via HTTP
// Generated from: @Route "GET /users/{id}"
func (s *UserServiceRemote) GetByID(p string) (*userdomain.UserDTO, error) {
	return proxy.CallWithData[*userdomain.UserDTO](s.proxyService, "GetByID", p)
}


func UserServiceFactory(deps map[string]any, config map[string]any) any {
	return &UserService{
		UserRepo: deps["user-repo"].(*service.Cached[any]),
	}
}

// UserServiceRemoteFactory creates a remote HTTP client for UserServiceInterface
// Auto-generated from @RouterService annotation
func UserServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewUserServiceRemote(proxyService)
}

// RegisterUserService registers the user-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="user-service", prefix="/api/v1/users"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterUserService() {
	// Register service type with router configuration
	lokstra_registry.RegisterServiceType("user-service-factory",
		UserServiceFactory,
		UserServiceRemoteFactory,
		deploy.WithRouter(&deploy.ServiceTypeRouter{
			PathPrefix:  "/api/v1/users",
			Middlewares: []string{  },
			CustomRoutes: map[string]string{
				"Create":  "POST /users",
				"GetByID":  "GET /users/{id}",
			},
		}),
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("user-service",
		"user-service-factory",
		map[string]any{
			"depends-on": []string{ "user-repo",  },
		})
}

