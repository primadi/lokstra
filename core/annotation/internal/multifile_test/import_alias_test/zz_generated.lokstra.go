// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by lokstra-annotation from annotations in this folder
// Annotations: @Handler, @Service, @Inject, @Route
//
// @Inject supports:
//   - "service-name"          : Direct service injection
//   - "@config.key"           : Service name from config value
//   - "cfg:config.key"        : Config value injection
//   - "cfg:@config.key"       : Config value via indirection

package main

import (
	userentity "github.com/primadi/lokstra/core/annotation/internal/multifile_test/import_alias_test/pkga"
	models "github.com/primadi/lokstra/core/annotation/internal/multifile_test/import_alias_test/pkgb"
	"github.com/primadi/lokstra/core/deploy"
	"github.com/primadi/lokstra/core/proxy"
	"github.com/primadi/lokstra/lokstra_registry"
)

// Auto-register on package import
func init() {
	RegisterServiceA()
	RegisterServiceB()
	RegisterServiceC()
	RegisterServiceD()
}

// ============================================================
// FILE: service_a.go
// ============================================================

// ServiceARemote implements ServiceAInterface with HTTP proxy
// Auto-generated from ServiceA interface methods
type ServiceARemote struct {
	proxyService *proxy.Service
}

// NewServiceARemote creates a new remote service-a proxy
func NewServiceARemote(proxyService *proxy.Service) *ServiceARemote {
	return &ServiceARemote{
		proxyService: proxyService,
	}
}

// GetUsers via HTTP
// Generated from: @Route "GET /users"
func (s *ServiceARemote) GetUsers() (*userentity.User, error) {
	return proxy.CallWithData[*userentity.User](s.proxyService, "GetUsers", nil)
}

// Process via HTTP
// Generated from: @Route "POST /process"
func (s *ServiceARemote) Process(p *userentity.Request) error {
	return proxy.Call(s.proxyService, "Process", p)
}

func ServiceAFactory(deps map[string]any, config map[string]any) any {
	svc := &ServiceA{}

	return svc
}

// ServiceARemoteFactory creates a remote HTTP client for ServiceAInterface
// Auto-generated from @Handler annotation
func ServiceARemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewServiceARemote(proxyService)
}

// RegisterServiceA registers the service-a with the registry
// Auto-generated from annotations:
//   - @Handler name="service-a", prefix="/api/a"
//   - @Route annotations on methods
func RegisterServiceA() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("service-a-factory",
		ServiceAFactory,
		ServiceARemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/a",
			Middlewares: []string{},
			RouteOverrides: map[string]deploy.RouteConfig{
				"GetUsers": {
					Path: "GET /users",
				},
				"Process": {
					Path: "POST /process",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("service-a",
		"service-a-factory",
		map[string]any{})
}

// ============================================================
// FILE: service_b.go
// ============================================================

// ServiceBRemote implements ServiceBInterface with HTTP proxy
// Auto-generated from ServiceB interface methods
type ServiceBRemote struct {
	proxyService *proxy.Service
}

// NewServiceBRemote creates a new remote service-b proxy
func NewServiceBRemote(proxyService *proxy.Service) *ServiceBRemote {
	return &ServiceBRemote{
		proxyService: proxyService,
	}
}

// GetUsers via HTTP
// Generated from: @Route "GET /users"
func (s *ServiceBRemote) GetUsers() (*models.User, error) {
	return proxy.CallWithData[*models.User](s.proxyService, "GetUsers", nil)
}

// Respond via HTTP
// Generated from: @Route "POST /respond"
func (s *ServiceBRemote) Respond() (*models.Response, error) {
	return proxy.CallWithData[*models.Response](s.proxyService, "Respond", nil)
}

func ServiceBFactory(deps map[string]any, config map[string]any) any {
	svc := &ServiceB{}

	return svc
}

// ServiceBRemoteFactory creates a remote HTTP client for ServiceBInterface
// Auto-generated from @Handler annotation
func ServiceBRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewServiceBRemote(proxyService)
}

// RegisterServiceB registers the service-b with the registry
// Auto-generated from annotations:
//   - @Handler name="service-b", prefix="/api/b"
//   - @Route annotations on methods
func RegisterServiceB() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("service-b-factory",
		ServiceBFactory,
		ServiceBRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/b",
			Middlewares: []string{},
			RouteOverrides: map[string]deploy.RouteConfig{
				"GetUsers": {
					Path: "GET /users",
				},
				"Respond": {
					Path: "POST /respond",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("service-b",
		"service-b-factory",
		map[string]any{})
}

// ============================================================
// FILE: service_c.go
// ============================================================

// ServiceCRemote implements ServiceCInterface with HTTP proxy
// Auto-generated from ServiceC interface methods
type ServiceCRemote struct {
	proxyService *proxy.Service
}

// NewServiceCRemote creates a new remote service-c proxy
func NewServiceCRemote(proxyService *proxy.Service) *ServiceCRemote {
	return &ServiceCRemote{
		proxyService: proxyService,
	}
}

// GetEntity via HTTP
// Generated from: @Route "GET /entity"
func (s *ServiceCRemote) GetEntity() (*userentity.User, error) {
	return proxy.CallWithData[*userentity.User](s.proxyService, "GetEntity", nil)
}

// HandleRequest via HTTP
// Generated from: @Route "POST /request"
func (s *ServiceCRemote) HandleRequest(p *userentity.Request) error {
	return proxy.Call(s.proxyService, "HandleRequest", p)
}

func ServiceCFactory(deps map[string]any, config map[string]any) any {
	svc := &ServiceC{}

	return svc
}

// ServiceCRemoteFactory creates a remote HTTP client for ServiceCInterface
// Auto-generated from @Handler annotation
func ServiceCRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewServiceCRemote(proxyService)
}

// RegisterServiceC registers the service-c with the registry
// Auto-generated from annotations:
//   - @Handler name="service-c", prefix="/api/c"
//   - @Route annotations on methods
func RegisterServiceC() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("service-c-factory",
		ServiceCFactory,
		ServiceCRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/c",
			Middlewares: []string{},
			RouteOverrides: map[string]deploy.RouteConfig{
				"GetEntity": {
					Path: "GET /entity",
				},
				"HandleRequest": {
					Path: "POST /request",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("service-c",
		"service-c-factory",
		map[string]any{})
}

// ============================================================
// FILE: service_d.go
// ============================================================

// ServiceDRemote implements ServiceDInterface with HTTP proxy
// Auto-generated from ServiceD interface methods
type ServiceDRemote struct {
	proxyService *proxy.Service
}

// NewServiceDRemote creates a new remote service-d proxy
func NewServiceDRemote(proxyService *proxy.Service) *ServiceDRemote {
	return &ServiceDRemote{
		proxyService: proxyService,
	}
}

// GetData via HTTP
// Generated from: @Route "GET /data"
func (s *ServiceDRemote) GetData() (*userentity.User, error) {
	return proxy.CallWithData[*userentity.User](s.proxyService, "GetData", nil)
}

// PerformAction via HTTP
// Generated from: @Route "POST /action"
func (s *ServiceDRemote) PerformAction(p *userentity.Request) error {
	return proxy.Call(s.proxyService, "PerformAction", p)
}

func ServiceDFactory(deps map[string]any, config map[string]any) any {
	svc := &ServiceD{}

	return svc
}

// ServiceDRemoteFactory creates a remote HTTP client for ServiceDInterface
// Auto-generated from @Handler annotation
func ServiceDRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewServiceDRemote(proxyService)
}

// RegisterServiceD registers the service-d with the registry
// Auto-generated from annotations:
//   - @Handler name="service-d", prefix="/api/d"
//   - @Route annotations on methods
func RegisterServiceD() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("service-d-factory",
		ServiceDFactory,
		ServiceDRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/d",
			Middlewares: []string{},
			RouteOverrides: map[string]deploy.RouteConfig{
				"GetData": {
					Path: "GET /data",
				},
				"PerformAction": {
					Path: "POST /action",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("service-d",
		"service-d-factory",
		map[string]any{})
}
