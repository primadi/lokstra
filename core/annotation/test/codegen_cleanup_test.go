package annotation_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/primadi/lokstra/core/annotation"
	"github.com/primadi/lokstra/core/annotation/internal"
)

// TestGenerateCodeForFolder_CleanupEmptyFile tests that zz_generated.lokstra.go
// is automatically deleted when all annotations are removed
func TestGenerateCodeForFolder_CleanupEmptyFile(t *testing.T) {
	tmpDir := t.TempDir()

	// Step 1: Create a file WITH @RouterService annotation
	contentWithAnnotation := `package application

// @RouterService name="user-service", prefix="/api/users"
type UserService struct {
	ID string
}
`
	filePath := filepath.Join(tmpDir, "user_service.go")
	if err := os.WriteFile(filePath, []byte(contentWithAnnotation), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	// Parse and generate code
	annotations, err := annotation.ParseFileAnnotations(filePath)
	if err != nil {
		t.Fatalf("ParseFileAnnotations() error = %v", err)
	}

	ctx := &annotation.RouterServiceContext{
		FolderPath: tmpDir,
		UpdatedFiles: []*annotation.FileToProcess{
			{
				Filename:    "user_service.go",
				FullPath:    filePath,
				Annotations: annotations,
			},
		},
		SkippedFiles: []*annotation.FileToProcess{},
		DeletedFiles: []string{},
		GeneratedCode: &annotation.GeneratedCode{
			Services:          make(map[string]*annotation.ServiceGeneration),
			PreservedSections: make(map[string]string),
		},
	}

	// Generate code - should create zz_generated.lokstra.go
	if err := annotation.GenerateCodeForFolder(ctx); err != nil {
		t.Fatalf("GenerateCodeForFolder() error = %v", err)
	}

	genPath := filepath.Join(tmpDir, internal.GeneratedFileName)
	if _, err := os.Stat(genPath); os.IsNotExist(err) {
		t.Fatalf("Expected %s to be created, but it doesn't exist", internal.GeneratedFileName)
	}

	t.Logf("✓ Step 1: Generated file created: %s", genPath)

	// Step 2: Remove annotation from file (simulate user removing @RouterService)
	contentWithoutAnnotation := `package application

// UserService is a service without annotation
type UserService struct {
	ID string
}
`
	if err := os.WriteFile(filePath, []byte(contentWithoutAnnotation), 0644); err != nil {
		t.Fatalf("Failed to update test file: %v", err)
	}

	// Parse again - should have no annotations
	annotations, err = annotation.ParseFileAnnotations(filePath)
	if err != nil {
		t.Fatalf("ParseFileAnnotations() error = %v", err)
	}

	if len(annotations) != 0 {
		t.Fatalf("Expected 0 annotations after removal, got %d", len(annotations))
	}

	// Generate code again with UpdatedFiles (annotation removed scenario)
	ctx2 := &annotation.RouterServiceContext{
		FolderPath: tmpDir,
		UpdatedFiles: []*annotation.FileToProcess{
			{
				Filename:    "user_service.go",
				FullPath:    filePath,
				Annotations: annotations, // Empty!
			},
		},
		SkippedFiles: []*annotation.FileToProcess{},
		DeletedFiles: []string{},
		GeneratedCode: &annotation.GeneratedCode{
			Services:          make(map[string]*annotation.ServiceGeneration),
			PreservedSections: make(map[string]string),
		},
	}

	if err := annotation.GenerateCodeForFolder(ctx2); err != nil {
		t.Fatalf("GenerateCodeForFolder() error = %v", err)
	}

	// Check that zz_generated.lokstra.go was DELETED
	if _, err := os.Stat(genPath); !os.IsNotExist(err) {
		t.Errorf("Expected %s to be deleted when no services remain, but it still exists", internal.GeneratedFileName)

		// Show file content for debugging
		if err == nil {
			content, _ := os.ReadFile(genPath)
			t.Logf("File content:\n%s", string(content))
		}
	} else {
		t.Logf("✓ Step 2: Generated file deleted: %s", genPath)
	}
}

// TestGenerateCodeForFolder_CleanupWhenSkipped tests cleanup when files are skipped
func TestGenerateCodeForFolder_CleanupWhenSkipped(t *testing.T) {
	tmpDir := t.TempDir()

	// Create an EMPTY zz_generated.lokstra.go (simulating orphaned file)
	genPath := filepath.Join(tmpDir, internal.GeneratedFileName)
	emptyGenContent := `// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by lokstra-annotation from annotations in this folder
// Annotations: @RouterService, @Inject, @Route

package application

import (
	"github.com/primadi/lokstra/core/deploy"
	"github.com/primadi/lokstra/core/proxy"
	"github.com/primadi/lokstra/lokstra_registry"
)

// Auto-register on package import
func init() {
}
`
	if err := os.WriteFile(genPath, []byte(emptyGenContent), 0644); err != nil {
		t.Fatalf("Failed to create test generated file: %v", err)
	}

	// Context with NO updated files, NO deleted files (all skipped)
	ctx := &annotation.RouterServiceContext{
		FolderPath:   tmpDir,
		UpdatedFiles: []*annotation.FileToProcess{},
		SkippedFiles: []*annotation.FileToProcess{
			{
				Filename: "user_service.go",
				FullPath: filepath.Join(tmpDir, "user_service.go"),
			},
		},
		DeletedFiles: []string{},
		GeneratedCode: &annotation.GeneratedCode{
			Services:          make(map[string]*annotation.ServiceGeneration),
			PreservedSections: make(map[string]string),
		},
	}

	// Generate code - should cleanup empty generated file
	if err := annotation.GenerateCodeForFolder(ctx); err != nil {
		t.Fatalf("GenerateCodeForFolder() error = %v", err)
	}

	// Check that zz_generated.lokstra.go was DELETED
	if _, err := os.Stat(genPath); !os.IsNotExist(err) {
		t.Errorf("Expected empty %s to be deleted when all files skipped, but it still exists", internal.GeneratedFileName)
	} else {
		t.Logf("✓ Empty generated file deleted when all files skipped")
	}
}
